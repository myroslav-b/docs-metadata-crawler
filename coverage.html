
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">docscrawler/app/crawler.go (92.9%)</option>
				
				<option value="file1">docscrawler/app/engine.go (89.9%)</option>
				
				<option value="file2">docscrawler/app/main.go (0.0%)</option>
				
				<option value="file3">docscrawler/app/researchers/msox.go (42.2%)</option>
				
				<option value="file4">docscrawler/app/researchers/pdf.go (55.9%)</option>
				
				<option value="file5">docscrawler/app/researchers/researcher.go (83.3%)</option>
				
				<option value="file6">docscrawler/app/urlstorage.go (97.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "net/http"
        "net/url"
        "time"

        "golang.org/x/net/html"
)

func harv(baseUrl *url.URL, urlStorage *tUrlStorage) <span class="cov8" title="1">{
        client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Get(baseUrl.String())
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return
        }</span>

        // Парсимо HTML
        <span class="cov8" title="1">z := html.NewTokenizer(resp.Body)
        for </span><span class="cov8" title="1">{
                tt := z.Next()
                switch tt </span>{
                case html.ErrorToken:<span class="cov8" title="1">
                        return</span> // Кінець документу
                case html.StartTagToken:<span class="cov8" title="1">
                        token := z.Token()

                        // Шукаємо теги &lt;a&gt;
                        if token.Data == "a" </span><span class="cov8" title="1">{
                                for _, attr := range token.Attr </span><span class="cov8" title="1">{
                                        if attr.Key == "href" </span><span class="cov8" title="1">{
                                                link := attr.Val

                                                // Обробляємо відносні URL
                                                url, err := resolveUrl(baseUrl.String(), link)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                // Додаємо лінк в слайс результатів, якщо він новий
                                                <span class="cov8" title="1">urlStorage.add(url)</span>
                                        }
                                }
                        }
                }
        }
}

func resolveUrl(baseStr string, href string) (*url.URL, error) <span class="cov8" title="1">{
        u, err := url.Parse(href)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">base, err := url.Parse(baseStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return base.ResolveReference(u), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bufio"
        "docscrawler/app/researchers"
        "errors"
        "fmt"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"
)

const crawlSleepTime = 5 * time.Second

type tEngine struct {
        url            *url.URL
        urlStorage     *tUrlStorage
        docStorage     map[string]researchers.Researcher
        docTypes       []string
        outputFileName string
        paramax        int
        mutex          sync.Mutex
}

func newEngine(opts tOpts) (*tEngine, error) <span class="cov8" title="1">{

        engine := new(tEngine)
        engine.urlStorage = newUrlStorage()
        engine.docStorage = make(map[string]researchers.Researcher)
        engine.docTypes = make([]string, len(opts.Type))

        for i, st := range opts.Type </span><span class="cov8" title="1">{
                ok := researchers.Is(st)
                if !ok </span><span class="cov8" title="1">{
                        return nil, errors.New("unknown document format for analysis")
                }</span>
                <span class="cov8" title="1">engine.docTypes[i] = st</span>
        }

        <span class="cov8" title="1">engine.outputFileName = opts.Output

        engine.paramax = opts.Paramax

        var err error
        engine.url, err = url.ParseRequestURI(opts.Site)
        if err != nil </span><span class="cov8" title="1">{
                return engine, errors.New("invalid URL")
        }</span>

        <span class="cov8" title="1">return engine, nil</span>
}

func (engine *tEngine) run() <span class="cov0" title="0">{
        engine.crawl()

        _ = engine.analyser()

        err := engine.output()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span>

}

func (engine *tEngine) crawl() <span class="cov8" title="1">{
        guard := make(chan bool, engine.paramax)
        defer close(guard)

        hostname := engine.url.Hostname()
        harv(engine.url, engine.urlStorage)

        for </span><span class="cov8" title="1">{
                urlBase, ok := engine.urlStorage.use()
                switch </span>{
                case !ok &amp;&amp; (len(guard) == 0):<span class="cov8" title="1">
                        return</span>
                case !ok &amp;&amp; (len(guard) &gt; 0):<span class="cov8" title="1">
                        time.Sleep(crawlSleepTime)</span>
                case ok:<span class="cov8" title="1">
                        if isValidScheme(urlBase) &amp;&amp; (hostname == urlBase.Hostname()) </span><span class="cov8" title="1">{
                                guard &lt;- true
                                urlCopy := *urlBase
                                go func(u *url.URL) </span><span class="cov8" title="1">{
                                        harv(u, engine.urlStorage)
                                        &lt;-guard
                                }</span>(&amp;urlCopy)
                        }
                }
        }
}

func (engine *tEngine) analyser() error <span class="cov8" title="1">{

        guard := make(chan bool, engine.paramax)
        defer close(guard)

        var wg sync.WaitGroup

        for _, url := range engine.urlStorage.getAllUrls() </span><span class="cov8" title="1">{
                url := url
                guard &lt;- true
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        engine.mutex.Lock()
                        defer engine.mutex.Unlock()

                        for _, t := range engine.docTypes </span><span class="cov8" title="1">{
                                if strings.HasSuffix(url.String(), "."+t) </span><span class="cov8" title="1">{
                                        eng := researchers.New(t)
                                        err := eng.Do(url.String())
                                        if err == nil </span><span class="cov0" title="0">{
                                                engine.docStorage[url.String()] = eng
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">&lt;-guard</span>

                }()
        }

        <span class="cov8" title="1">wg.Wait()

        return nil</span>
}

func isValidScheme(u *url.URL) bool <span class="cov8" title="1">{
        return u.Scheme == "http" || u.Scheme == "https"
}</span>

func (engine *tEngine) output() error <span class="cov8" title="1">{
        //st := ""
        var out *os.File
        var err error

        if engine.outputFileName == "" </span><span class="cov8" title="1">{
                out = os.Stdout
        }</span> else<span class="cov8" title="1"> {
                out, err = os.Create(engine.outputFileName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer out.Close()</span>
        }

        <span class="cov8" title="1">bufout := bufio.NewWriter(out)
        defer bufout.Flush()
        bufout.WriteString("[")
        isFirst := true
        for _, url := range engine.urlStorage.getAllUrls() </span><span class="cov8" title="1">{
                rr, exists := engine.docStorage[url.String()]
                if exists </span><span class="cov8" title="1">{
                        if !isFirst </span><span class="cov0" title="0">{
                                bufout.WriteString(",")
                        }</span>
                        <span class="cov8" title="1">isFirst = false
                        _ = rr.OutJSON(bufout)</span>
                }
        }

        <span class="cov8" title="1">bufout.WriteString("]")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "os"

        "github.com/jessevdk/go-flags"
)

type tOpts struct {
        Site    string   `short:"s" long:"site" required:"true" description:"site name"`
        Type    []string `short:"t" long:"type" choice:"pdf" choice:"docx" choice:"xlsx" choice:"pptx" description:"document type / file name extension (all if empty)"`
        Output  string   `short:"o" long:"output" default:"" description:"output stream, stdout if none"`
        Paramax int      `short:"p" long:"paramax" default:"100" description:"maximum number of parallel analysis threads"`
}

func main() <span class="cov0" title="0">{
        var opts tOpts

        parser := flags.NewParser(&amp;opts, flags.Default)

        if _, err := parser.Parse(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">typeOption := parser.FindOptionByLongName("type")
        allowDocTypes := typeOption.Choices
        if len(opts.Type) == 0 </span><span class="cov0" title="0">{
                opts.Type = allowDocTypes
        }</span>

        <span class="cov0" title="0">engine, err := newEngine(opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Engine initialization error: %v", err)
        }</span>

        <span class="cov0" title="0">engine.run()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package researchers

import (
        "archive/zip"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"
)

type tCoreProperty struct {
        XMLName        xml.Name `xml:"coreProperties" json:"coreProperties,omitempty"`
        Title          string   `xml:"title" json:"title,omitempty"`
        Creator        string   `xml:"creator" json:"creator,omitempty"`
        LastModifiedBy string   `xml:"lastModifiedBy" json:"lastModifiedBy,omitempty"`
        Revision       string   `xml:"revision" json:"revision,omitempty"`
        Created        string   `xml:"created" json:"created,omitempty"`
        Modified       string   `xml:"modified" json:"modified,omitempty"`
        Language       string   `xml:"language" json:"language,omitempty"`
}

type tAppProperty struct {
        XMLName     xml.Name `xml:"Properties" json:"properties,omitempty"`
        Application string   `xml:"Application" json:"application,omitempty"`
        DocSecurity string   `xml:"DocSecurity" json:"doc_security,omitempty"`
        Pages       string   `xml:"Pages" json:"pages,omitempty"`
        Words       string   `xml:"Words" json:"words,omitempty"`
        Characters  string   `xml:"Characters" json:"characters,omitempty"`
        Company     string   `xml:"Company" json:"company,omitempty"`
        Lines       string   `xml:"Lines" json:"lines,omitempty" `
        Paragraphs  string   `xml:"Paragraphs" json:"paragraphs,omitempty"`
        TotalTime   string   `xml:"TotalTime" json:"total_time,omitempty"`
        SharedDoc   string   `xml:"SharedDoc" json:"shared_doc,omitempty"`
        AppVersion  string   `xml:"AppVersion" json:"app_version,omitempty"`
}

type tMsox struct {
        docType      string
        Url          string `json:"url,omitempty"`
        CoreProperty tCoreProperty
        AppProperty  tAppProperty
}

func newMsox() *tMsox <span class="cov8" title="1">{
        return new(tMsox)
}</span>

func (msox *tMsox) OutJSON(writer io.Writer) error <span class="cov8" title="1">{
        data, err := json.Marshal(msox)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = writer.Write(data)
        return err</span>
}

func (msox *tMsox) Do(url string) error <span class="cov8" title="1">{
        msox.docType = "msox"
        msox.Url = url

        client := http.Client{
                Timeout: httpGetTimeout * time.Second,
        }
        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{ // Перевірка статусу 200 OK
                // Можна прочитати тіло відповіді для детальнішої помилки, якщо потрібно
                return fmt.Errorf("failed to download file: status code %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">respReadSeeker, err := readCloserToReadSeekerFile(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tmpFileName := respReadSeeker.Name()
        rZip, err := zip.OpenReader(tmpFileName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">defer rZip.Close()
        for _, fInZip := range rZip.File </span><span class="cov0" title="0">{
                switch fInZip.Name </span>{
                case "docProps/core.xml":<span class="cov0" title="0">
                        rc1, err := fInZip.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer rc1.Close()
                        err = xml.NewDecoder(rc1).Decode(&amp;msox.CoreProperty)
                        //rc.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "docProps/app.xml":<span class="cov0" title="0">
                        rc2, err := fInZip.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer rc2.Close()
                        err = xml.NewDecoder(rc2).Decode(&amp;msox.AppProperty)
                        //rc.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }
        }

        <span class="cov0" title="0">respReadSeeker.Close()
        err = os.Remove(tmpFileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//// https://www.pdf2go.com/blog/pdf-metadata
// https://pkg.go.dev/seehuhn.de/go/pdf#Info
// https://github.com/divan/pdfreader
// https://github.com/yob/pdfreader
// https://github.com/jung-kurt/gofpdf
// https://www.example-code.com/golang/pdf_signatures.asp

package researchers

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/pdfcpu/pdfcpu/pkg/api"
        "github.com/pdfcpu/pdfcpu/pkg/pdfcpu/model"
)

type tPdf struct {
        docType      string
        Url          string `json:"url,omitempty"`
        FileName     string `json:"source,omitempty"`
        Version      string `json:"version,omitempty"`
        Title        string `json:"title,omitempty"`
        Author       string `json:"author,omitempty"`
        Subject      string `json:"subject,omitempty"`
        Producer     string `json:"producer,omitempty"`
        Creator      string `json:"creator,omitempty"`
        CreationDate string `json:"creation_date,omitempty"`
        ModDate      string `json:"mod_date,omitempty"`
}

func newPdf() *tPdf <span class="cov8" title="1">{
        return new(tPdf)
}</span>

func (pdf *tPdf) OutJSON(writer io.Writer) error <span class="cov8" title="1">{
        data, err := json.Marshal(pdf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = writer.Write(data)
        return err</span>
}

func (pdf *tPdf) Do(url string) error <span class="cov8" title="1">{
        pdf.docType = "pdf"
        pdf.Url = url

        client := http.Client{
                Timeout: httpGetTimeout * time.Second,
        }
        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{ // Перевірка статусу 200 OK
                // Можна прочитати тіло відповіді для детальнішої помилки, якщо потрібно
                return fmt.Errorf("failed to download file: status code %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">respReadSeeker, err := readCloserToReadSeekerFile(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tmpFileName := respReadSeeker.Name()
        info, err := api.PDFInfo(respReadSeeker, tmpFileName, nil, model.NewDefaultConfiguration())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">respReadSeeker.Close()
        err = os.Remove(tmpFileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pdf.Title = info.Title
        pdf.Author = info.Author
        pdf.Subject = info.Subject
        pdf.Creator = info.Creator
        pdf.Producer = info.Producer
        pdf.CreationDate = info.CreationDate
        pdf.ModDate = info.ModificationDate

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package researchers

import (
        "fmt"
        "io"
        "os"
)

const (
        httpGetTimeout = 30
        maxFileSize    = 100 * 1024 * 1024
)

var allFileTypes = map[string]func() Researcher{
        "pdf":  func() Researcher <span class="cov8" title="1">{ return newPdf() }</span>,
        "docx": func() Researcher <span class="cov8" title="1">{ return newMsox() }</span>,
        "xlsx": func() Researcher <span class="cov8" title="1">{ return newMsox() }</span>,
        "pptx": func() Researcher <span class="cov8" title="1">{ return newMsox() }</span>,
}

func Is(st string) bool <span class="cov8" title="1">{
        _, exist := allFileTypes[st]
        return exist
}</span>

func New(st string) Researcher <span class="cov8" title="1">{
        f := allFileTypes[st]
        return f()
}</span>

type Researcher interface {
        OutJSON(writer io.Writer) error
        Do(url string) error
}

func readCloserToReadSeekerFile(rc io.ReadCloser) (*os.File, error) <span class="cov8" title="1">{

        // Створюємо тимчасовий файл
        tmpFile, err := os.CreateTemp("", "readseeker-*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Копіюємо дані
        <span class="cov8" title="1">limitedReader := &amp;io.LimitedReader{R: rc, N: maxFileSize}
        _, err = io.Copy(tmpFile, limitedReader)
        if err != nil </span><span class="cov8" title="1">{
                tmpFileName := tmpFile.Name()
                tmpFile.Close()
                os.Remove(tmpFileName)
                return nil, err
        }</span>
        // Перевірка, чи не було досягнуто ліміту (означає, що файл завеликий)
        <span class="cov8" title="1">if limitedReader.N == 0 </span><span class="cov8" title="1">{
                tmpFileName := tmpFile.Name()
                tmpFile.Close()
                os.Remove(tmpFileName)
                return nil, fmt.Errorf("file exceeds maximum allowed size of %d bytes", maxFileSize)
        }</span>

        // Переходимо на початок
        <span class="cov8" title="1">_, err = tmpFile.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                tmpFileName := tmpFile.Name()
                tmpFile.Close()
                os.Remove(tmpFileName)
                return nil, err
        }</span>

        <span class="cov8" title="1">return tmpFile, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "net/url"
        "sync"
)

/*
type tUrlStorage struct {
        sync.RWMutex // Додаємо RWMutex для контролю доступу
        urls         map[url.URL]bool
}

func newUrlStorage() *tUrlStorage {
        urlStorage := new(tUrlStorage)
        urlStorage.urls = make(map[url.URL]bool)
        return urlStorage
}

func (urlStorage *tUrlStorage) add(url *url.URL) bool {
        urlStorage.Lock()         // Блокуємо доступ перед модифікацією
        defer urlStorage.Unlock() // Гарантуємо розблокування після завершення

        if _, exists := urlStorage.urls[*url]; exists {
                return false // URL вже існує
        }
        urlStorage.urls[*url] = false
        return true
}

func (urlStorage *tUrlStorage) check(url *url.URL) (bool, bool) {
        urlStorage.RLock() // Використовуємо RLock для операції читання
        defer urlStorage.RUnlock()

        v, ok := urlStorage.urls[*url]
        return ok, v
}

func (urlStorage *tUrlStorage) getAllUrls() []*url.URL {
        urlStorage.RLock() // Використовуємо RLock для операції читання
        defer urlStorage.RUnlock()

        allUrl := make([]*url.URL, 0, len(urlStorage.urls))

        for url := range urlStorage.urls {
                allUrl = append(allUrl, &amp;url)
        }

        return allUrl
}

func (urlStorage *tUrlStorage) use() (*url.URL, bool) {
        urlStorage.Lock()         // Блокуємо доступ перед модифікацією
        defer urlStorage.Unlock() // Гарантуємо розблокування після завершення

        for url, used := range urlStorage.urls {
                if !used {
                        urlStorage.urls[url] = true
                        return &amp;url, true
                }
        }
        return nil, false
}
*/

type tUrlStorage struct {
        mu         sync.RWMutex        // Додаємо RWMutex для контролю доступу
        urlStatus  map[string]bool     // Статус URL (true - використаний)
        urlObjects map[string]*url.URL // Відповідність рядкових ключів до URL об'єктів
        queue      []string            // Черга URL для обробки
}

func newUrlStorage() *tUrlStorage <span class="cov8" title="1">{
        return &amp;tUrlStorage{
                urlStatus:  make(map[string]bool),
                urlObjects: make(map[string]*url.URL),
                queue:      make([]string, 0, 100),
        }
}</span>

// Add додає новий URL до сховища, якщо він ще не існує
func (us *tUrlStorage) add(u *url.URL) bool <span class="cov8" title="1">{
        if u == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">us.mu.Lock()
        defer us.mu.Unlock()

        key := u.String()

        // Перевіряємо, чи URL вже існує
        if _, exists := us.urlStatus[key]; exists </span><span class="cov8" title="1">{
                return false
        }</span>

        // Зберігаємо копію URL
        <span class="cov8" title="1">urlCopy := *u // Створюємо копію структури URL
        us.urlObjects[key] = &amp;urlCopy
        us.urlStatus[key] = false // false = не використаний
        us.queue = append(us.queue, key)

        return true</span>
}

// Use повертає невикористаний URL і позначає його як використаний
func (us *tUrlStorage) use() (*url.URL, bool) <span class="cov8" title="1">{
        us.mu.Lock()
        defer us.mu.Unlock()

        // Шукаємо невикористаний URL в черзі
        for i := 0; i &lt; len(us.queue); i++ </span><span class="cov8" title="1">{
                key := us.queue[i]

                if !us.urlStatus[key] </span><span class="cov8" title="1">{
                        // Позначаємо як використаний
                        us.urlStatus[key] = true

                        // Видаляємо з черги (швидке видалення без збереження порядку)
                        us.queue[i] = us.queue[len(us.queue)-1]
                        us.queue = us.queue[:len(us.queue)-1]

                        return us.urlObjects[key], true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

// GetAllURLs повертає всі URL, що зберігаються в сховищі
func (us *tUrlStorage) getAllUrls() []*url.URL <span class="cov8" title="1">{
        us.mu.RLock()
        defer us.mu.RUnlock()

        result := make([]*url.URL, 0, len(us.urlObjects))

        for _, urlObj := range us.urlObjects </span><span class="cov8" title="1">{
                // Важливо: повертаємо саме збережені покажчики, а не створюємо нові
                result = append(result, urlObj)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Check перевіряє, чи URL існує в сховищі та чи він вже використаний
func (us *tUrlStorage) check(u *url.URL) (exists bool, used bool) <span class="cov8" title="1">{
        if u == nil </span><span class="cov0" title="0">{
                return false, false
        }</span>

        <span class="cov8" title="1">us.mu.RLock()
        defer us.mu.RUnlock()

        key := u.String()
        used, exists = us.urlStatus[key]
        return exists, used</span>
}

// Count повертає кількість URL у сховищі
func (us *tUrlStorage) count() (total int, used int) <span class="cov8" title="1">{
        us.mu.RLock()
        defer us.mu.RUnlock()

        total = len(us.urlStatus)

        for _, isUsed := range us.urlStatus </span><span class="cov8" title="1">{
                if isUsed </span><span class="cov8" title="1">{
                        used++
                }</span>
        }

        <span class="cov8" title="1">return total, used</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
